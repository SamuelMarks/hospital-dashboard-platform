/**
 * Hospital Analytics Platform
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpContext,
} from '@angular/common/http';
import { Observable } from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { DashboardCreate } from '../model/dashboard-create';
// @ts-ignore
import { DashboardResponse } from '../model/dashboard-response';
// @ts-ignore
import { HTTPValidationError } from '../model/http-validation-error';
// @ts-ignore
import { WidgetIn } from '../model/widget-in';
// @ts-ignore
import { WidgetReorderRequest } from '../model/widget-reorder-request';
// @ts-ignore
import { WidgetResponse } from '../model/widget-response';
// @ts-ignore
import { WidgetUpdate } from '../model/widget-update';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { BaseService } from '../api.base.service';

@Injectable({
  providedIn: 'root',
})
export class DashboardsService extends BaseService {
  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration?: Configuration,
  ) {
    super(basePath, configuration);
  }

  /**
   * Clone Dashboard
   * Creates a deep copy of an existing dashboard and all its widgets. The new dashboard will have the name \&quot;Copy of {original_name}\&quot;.  Args:     dashboard_id (UUID): The ID of the dashboard to clone.     current_user (User): Authenticated user (must own the dashboard).     db (AsyncSession): Database session.  Returns:     DashboardResponse: The newly created dashboard populated with cloned widgets.
   * @endpoint post /api/v1/dashboards/{dashboard_id}/clone
   * @param dashboardId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public cloneDashboardApiV1DashboardsDashboardIdClonePost(
    dashboardId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<DashboardResponse>;
  public cloneDashboardApiV1DashboardsDashboardIdClonePost(
    dashboardId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<DashboardResponse>>;
  public cloneDashboardApiV1DashboardsDashboardIdClonePost(
    dashboardId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<DashboardResponse>>;
  public cloneDashboardApiV1DashboardsDashboardIdClonePost(
    dashboardId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (dashboardId === null || dashboardId === undefined) {
      throw new Error(
        'Required parameter dashboardId was null or undefined when calling cloneDashboardApiV1DashboardsDashboardIdClonePost.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/${this.configuration.encodeParam({ name: 'dashboardId', value: dashboardId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: 'uuid' })}/clone`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<DashboardResponse>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * Create Dashboard
   * Create a new empty dashboard.
   * @endpoint post /api/v1/dashboards/
   * @param dashboardCreate
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public createDashboardApiV1DashboardsPost(
    dashboardCreate: DashboardCreate,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<DashboardResponse>;
  public createDashboardApiV1DashboardsPost(
    dashboardCreate: DashboardCreate,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<DashboardResponse>>;
  public createDashboardApiV1DashboardsPost(
    dashboardCreate: DashboardCreate,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<DashboardResponse>>;
  public createDashboardApiV1DashboardsPost(
    dashboardCreate: DashboardCreate,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (dashboardCreate === null || dashboardCreate === undefined) {
      throw new Error(
        'Required parameter dashboardCreate was null or undefined when calling createDashboardApiV1DashboardsPost.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<DashboardResponse>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: dashboardCreate,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * Create Widget
   * Add a widget to the dashboard with Dry-Run Validation.
   * @endpoint post /api/v1/dashboards/{dashboard_id}/widgets
   * @param dashboardId
   * @param widgetIn
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public createWidgetApiV1DashboardsDashboardIdWidgetsPost(
    dashboardId: string,
    widgetIn: WidgetIn,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<WidgetResponse>;
  public createWidgetApiV1DashboardsDashboardIdWidgetsPost(
    dashboardId: string,
    widgetIn: WidgetIn,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<WidgetResponse>>;
  public createWidgetApiV1DashboardsDashboardIdWidgetsPost(
    dashboardId: string,
    widgetIn: WidgetIn,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<WidgetResponse>>;
  public createWidgetApiV1DashboardsDashboardIdWidgetsPost(
    dashboardId: string,
    widgetIn: WidgetIn,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (dashboardId === null || dashboardId === undefined) {
      throw new Error(
        'Required parameter dashboardId was null or undefined when calling createWidgetApiV1DashboardsDashboardIdWidgetsPost.',
      );
    }
    if (widgetIn === null || widgetIn === undefined) {
      throw new Error(
        'Required parameter widgetIn was null or undefined when calling createWidgetApiV1DashboardsDashboardIdWidgetsPost.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/${this.configuration.encodeParam({ name: 'dashboardId', value: dashboardId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: 'uuid' })}/widgets`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<WidgetResponse>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: widgetIn,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * Delete Dashboard
   * Delete dashboard (and cascades to widgets).
   * @endpoint delete /api/v1/dashboards/{dashboard_id}
   * @param dashboardId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public deleteDashboardApiV1DashboardsDashboardIdDelete(
    dashboardId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any>;
  public deleteDashboardApiV1DashboardsDashboardIdDelete(
    dashboardId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<any>>;
  public deleteDashboardApiV1DashboardsDashboardIdDelete(
    dashboardId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<any>>;
  public deleteDashboardApiV1DashboardsDashboardIdDelete(
    dashboardId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (dashboardId === null || dashboardId === undefined) {
      throw new Error(
        'Required parameter dashboardId was null or undefined when calling deleteDashboardApiV1DashboardsDashboardIdDelete.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/${this.configuration.encodeParam({ name: 'dashboardId', value: dashboardId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: 'uuid' })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<any>('delete', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * Delete Widget
   * Delete a widget owned by the current user.
   * @endpoint delete /api/v1/dashboards/widgets/{widget_id}
   * @param widgetId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public deleteWidgetApiV1DashboardsWidgetsWidgetIdDelete(
    widgetId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any>;
  public deleteWidgetApiV1DashboardsWidgetsWidgetIdDelete(
    widgetId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<any>>;
  public deleteWidgetApiV1DashboardsWidgetsWidgetIdDelete(
    widgetId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<any>>;
  public deleteWidgetApiV1DashboardsWidgetsWidgetIdDelete(
    widgetId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (widgetId === null || widgetId === undefined) {
      throw new Error(
        'Required parameter widgetId was null or undefined when calling deleteWidgetApiV1DashboardsWidgetsWidgetIdDelete.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/widgets/${this.configuration.encodeParam({ name: 'widgetId', value: widgetId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: 'uuid' })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<any>('delete', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * Get Dashboard
   * Get a specific dashboard details.
   * @endpoint get /api/v1/dashboards/{dashboard_id}
   * @param dashboardId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public getDashboardApiV1DashboardsDashboardIdGet(
    dashboardId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<DashboardResponse>;
  public getDashboardApiV1DashboardsDashboardIdGet(
    dashboardId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<DashboardResponse>>;
  public getDashboardApiV1DashboardsDashboardIdGet(
    dashboardId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<DashboardResponse>>;
  public getDashboardApiV1DashboardsDashboardIdGet(
    dashboardId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (dashboardId === null || dashboardId === undefined) {
      throw new Error(
        'Required parameter dashboardId was null or undefined when calling getDashboardApiV1DashboardsDashboardIdGet.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/${this.configuration.encodeParam({ name: 'dashboardId', value: dashboardId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: 'uuid' })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<DashboardResponse>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * List Dashboards
   * List all dashboards owned by the current user.
   * @endpoint get /api/v1/dashboards/
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public listDashboardsApiV1DashboardsGet(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<Array<DashboardResponse>>;
  public listDashboardsApiV1DashboardsGet(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<Array<DashboardResponse>>>;
  public listDashboardsApiV1DashboardsGet(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<Array<DashboardResponse>>>;
  public listDashboardsApiV1DashboardsGet(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<Array<DashboardResponse>>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * Reorder Widgets
   * Bulk update widget positions and groups. Used for Drag-and-Drop persistence.
   * @endpoint post /api/v1/dashboards/{dashboard_id}/reorder
   * @param dashboardId
   * @param widgetReorderRequest
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public reorderWidgetsApiV1DashboardsDashboardIdReorderPost(
    dashboardId: string,
    widgetReorderRequest: WidgetReorderRequest,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<{ [key: string]: any }>;
  public reorderWidgetsApiV1DashboardsDashboardIdReorderPost(
    dashboardId: string,
    widgetReorderRequest: WidgetReorderRequest,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<{ [key: string]: any }>>;
  public reorderWidgetsApiV1DashboardsDashboardIdReorderPost(
    dashboardId: string,
    widgetReorderRequest: WidgetReorderRequest,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<{ [key: string]: any }>>;
  public reorderWidgetsApiV1DashboardsDashboardIdReorderPost(
    dashboardId: string,
    widgetReorderRequest: WidgetReorderRequest,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (dashboardId === null || dashboardId === undefined) {
      throw new Error(
        'Required parameter dashboardId was null or undefined when calling reorderWidgetsApiV1DashboardsDashboardIdReorderPost.',
      );
    }
    if (widgetReorderRequest === null || widgetReorderRequest === undefined) {
      throw new Error(
        'Required parameter widgetReorderRequest was null or undefined when calling reorderWidgetsApiV1DashboardsDashboardIdReorderPost.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/${this.configuration.encodeParam({ name: 'dashboardId', value: dashboardId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: 'uuid' })}/reorder`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<{ [key: string]: any }>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: widgetReorderRequest,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * Restore Default Dashboard
   * Re-creates the standard \&#39;Hospital Command Center\&#39; dashboard. If the dashboard already exists, creates a copy with a suffix to prevent data loss. Populates the dashboard with all currently active templates in the registry.
   * @endpoint post /api/v1/dashboards/restore-defaults
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public restoreDefaultDashboardApiV1DashboardsRestoreDefaultsPost(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<DashboardResponse>;
  public restoreDefaultDashboardApiV1DashboardsRestoreDefaultsPost(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<DashboardResponse>>;
  public restoreDefaultDashboardApiV1DashboardsRestoreDefaultsPost(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<DashboardResponse>>;
  public restoreDefaultDashboardApiV1DashboardsRestoreDefaultsPost(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/restore-defaults`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<DashboardResponse>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * Update Dashboard
   * Rename a dashboard.
   * @endpoint put /api/v1/dashboards/{dashboard_id}
   * @param dashboardId
   * @param dashboardCreate
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public updateDashboardApiV1DashboardsDashboardIdPut(
    dashboardId: string,
    dashboardCreate: DashboardCreate,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<DashboardResponse>;
  public updateDashboardApiV1DashboardsDashboardIdPut(
    dashboardId: string,
    dashboardCreate: DashboardCreate,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<DashboardResponse>>;
  public updateDashboardApiV1DashboardsDashboardIdPut(
    dashboardId: string,
    dashboardCreate: DashboardCreate,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<DashboardResponse>>;
  public updateDashboardApiV1DashboardsDashboardIdPut(
    dashboardId: string,
    dashboardCreate: DashboardCreate,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (dashboardId === null || dashboardId === undefined) {
      throw new Error(
        'Required parameter dashboardId was null or undefined when calling updateDashboardApiV1DashboardsDashboardIdPut.',
      );
    }
    if (dashboardCreate === null || dashboardCreate === undefined) {
      throw new Error(
        'Required parameter dashboardCreate was null or undefined when calling updateDashboardApiV1DashboardsDashboardIdPut.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/${this.configuration.encodeParam({ name: 'dashboardId', value: dashboardId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: 'uuid' })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<DashboardResponse>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: dashboardCreate,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }

  /**
   * Update Widget
   * Update widget configuration (e.g., resize, change query) with Dry-Run.
   * @endpoint put /api/v1/dashboards/widgets/{widget_id}
   * @param widgetId
   * @param widgetUpdate
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param options additional options
   */
  public updateWidgetApiV1DashboardsWidgetsWidgetIdPut(
    widgetId: string,
    widgetUpdate: WidgetUpdate,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<WidgetResponse>;
  public updateWidgetApiV1DashboardsWidgetsWidgetIdPut(
    widgetId: string,
    widgetUpdate: WidgetUpdate,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<WidgetResponse>>;
  public updateWidgetApiV1DashboardsWidgetsWidgetIdPut(
    widgetId: string,
    widgetUpdate: WidgetUpdate,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<WidgetResponse>>;
  public updateWidgetApiV1DashboardsWidgetsWidgetIdPut(
    widgetId: string,
    widgetUpdate: WidgetUpdate,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (widgetId === null || widgetId === undefined) {
      throw new Error(
        'Required parameter widgetId was null or undefined when calling updateWidgetApiV1DashboardsWidgetsWidgetIdPut.',
      );
    }
    if (widgetUpdate === null || widgetUpdate === undefined) {
      throw new Error(
        'Required parameter widgetUpdate was null or undefined when calling updateWidgetApiV1DashboardsWidgetsWidgetIdPut.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (OAuth2PasswordBearer) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'OAuth2PasswordBearer',
      'Authorization',
      localVarHeaders,
      'Bearer ',
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/api/v1/dashboards/widgets/${this.configuration.encodeParam({ name: 'widgetId', value: widgetId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: 'uuid' })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<WidgetResponse>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: widgetUpdate,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
      reportProgress: reportProgress,
    });
  }
}
